---

layout: post

title: "再刷DVWA"

author: "markt"

---

## 1.暴力破解

回头再来看dvwa的暴力破解，很容易就联想到拖库，因为在这里暴力和sql注入同时出现了，而实际情况中暴力破解也总是和拖库联系在一起。

一般来说，最简单的防御就是验证码和CSRF Token，省时省力。

同样也不是说上述防御一定安全，验证码可以机器识别，token也能自己写脚本破解（可以考虑burp的宏会话）。

## 2.注入类

不论是命令注入，SQL注入还是文件包含之类的其实都可以统称为注入。需要关注的地方：一是用户输入可控；二是用户输入在服务器端实现的方式，是数据库查询呢，还是打开文件、使用终端命令之类的；三是注意回显，用户输入和页面之间的联系，各种注入是否有错误回显。能想到的暂时就这么多了。

另外，也可以根据反向思路寻找，有过滤或者是限制用户输入的地方，漏洞存在的可能性就越大。而不管是正向寻找还是反推，考验人智商的地方在于黑盒绕过。这时最需要的就是冷静且头脑清晰了。

### SQL注入

注意区分字符型注入和数字型注入，前者要关注字符串引号的闭合。另外还需要注意的一点是注入的类型，最简单的GET注入已经很少见了，更多的是POST和Cookie注入，应注意这两种注入的工具注入方法。

基于黑名单式的防御不必多说，多试试总会有问题的。而php中常见的mysql_real_escape_string()函数也不见得是万能的，最起码宽字节注入就能解决。最可靠的还是参数化查询，即PDO预处理模式。

#### 盲注

盲注就是没有回显，解决的办法是两种：基于布尔、基于延迟。简单的例子：普通注入就是你问小孩啥他回答啥，布尔型就是他只能点头或者摇头，而延迟型就是看他有没有激烈的思想斗争。具体实现最好的方式还是sqlmap，另外就是自己写脚本，手工的工作量太大。

另外回答自己之前文章的疑问：

> ### 一个疑惑
>
> 在面对字符型注入时，把其误认为数字型注入的错误注入居然能返回一条正确的数据？
>
> 源码：`$query = "SELECT first_name, last_name FROM users WHERE user_id = '$id';";`
>
> 当payload（即id变量）为：`2 or 1=1 #`（正确的字符注入应多一个’闭合引号：`2' or 1=1 #`）
>
> 成功返回了原本id=2时的正确结果，即查询语句成为了：
>
> ```
> SELECT first_name, last_name FROM users WHERE user_id = '2 or 1=1 #';
> ```
>
> 返回了
>
> ```
> SELECT first_name, last_name FROM users WHERE user_id = '2';
> ```
>
> 的内容。所以是什么原因？

在mysql中，在进行非同类型比较或者其他需要类型转换的时候，字符型向数字型转换时会取最前面的数字作为其值，也就是说上例中`2 or 1=1 #` 被强制转换为了数字`2` ，所以出现id=2的查询结果也就合理了。

## 3.文件上传

文件上传在DVWA中可以说是很简单了，主要是用于让人熟悉其防御机制。

从实际情况来看，文件上传主要要关注的地方有：

1. 上传路径；不要指望系统在你上传成功以后还告诉你上传到哪了；
2. 文件名；有的系统会对上传文件重命名；
3. 后缀；存在系统改后缀的可能，同样低版本的某些语言会把含有该语言的文本当作脚本解析；
4. 防御措施；黑名单？白名单？前端？后端？文件类型？文件内容？后缀？

## 4. 验证码

在DVWA中的验证码主要是说不安全的CAPTCHA，而其本质上应该属于后者的一个子集，也可以说是后者的一种比较典型的光而用之的实现形式。而不安全的CAPTCHA主要还是说的是验证机制的逻辑漏洞问题。

从实际情况来说，验证码主要的用处还是防御爆破，可以说，其主要是通过验证是否机器操作来防止爆破。而在DVWA中则是一种用来分辨人机操作的较为鸡肋的设计，更像是为了防止CSRF。因为从实际情况来说几乎没有说是在改密码的时候输入验证码的。

## 5.XSS

与注入也差不多，就是数据被当作了指令造成的后果，而区别在于注入的执行者是服务器端，而XSS是客户端的浏览器。而一般来说XSS都是被用来获得用户cookie的，不过作为浏览器端的脚本语言JavaScript能干的事同样也很多（并不），这取决于你的脑洞了。XSS蠕虫了解一下。

说完能干什么再来说说怎么干。常见的XSS形式一般主要是一直接上js脚本二各种on事件，防御搞定以后就交给XSS平台，这是效率最高的办法。

## 结语

又把DVWA走马观花地看了一遍，算是复习吧。我觉得最主要还是要关注：

1. 什么漏洞主要在什么地方出现，能干什么；
2. 各种漏洞的绕过与反绕过，比如各种过滤函数。

另外，牵扯到具体的实际环境中，还应该了解对应工具怎么用。就先这样吧。