---

layout: post

title: " DVWA笔记9&10（XSS）"

author: "markt"

---

## 原理

之前自己笔记：

>## 	       XSS（跨站脚本（攻击））
>
>```
>通过各种方法让用户在客户端的浏览器上使用你的脚本。
>```
>
>分为反射型（经过服务端一来一回故反射）、存储型（存储到服务端）、DOM型（客户端本地执行靠浏览器DOM解析）
>
>由于攻击代码较长，一般都是通过引用第三方的脚本代码。
>
>**反射型和DOM型都是通过修改URL参数来实现的，前者经过服务器端再到客户端，后者直接通过浏览器前端进行页面渲染。反射型和存储型都经过服务器端，但是前者修改的是URL参数，后者是从数据库中直接读出脚本**

## 读道哥白帽子的笔记

反射型（非持久型）XSS：虽然也经过了服务器端，但是实际上还是比较难以利用的，需要用户配合才可以，有点CSRF的味道。不配合利用的话，有时候会出现只能自己攻击自己的尴尬情况。

存储型（持久型）XSS：存储到了服务器端，所以用户都能访问到，隐蔽性较强。例如留言板之类。

### 疑问

写到这里，突然对XSS的分类产生了疑问。有种咬文嚼字的意思。那么：

如果按道哥书上所说，所谓**DOM型XSS指的是通过修改页面的DOM节点形成的XSS**，且**反射型XSS只是简单地把用户输入经过服务端再返回给浏览器**，那么仅仅是**因为绕过姿势的原因**修改了DOM节点，而将DOM型XSS独自划分为一类却不属于反射型XSS真的合适？

况且，如果按道哥所说，反射型XSS**“往往需要诱使用户点击恶意链接才能攻击成功"**的话，那么和CSRF又有何区别呢？书上后文对XSS的利用经常出现CSRF的精髓，可能XSS很多的利用方法还是离不开请求伪造吧。（没必要对一个分类计较，不钻牛角尖了，改天好好看看余弦的书是怎么说的吧。）

刚刚看到网上一个说法很有趣：

> xss：用户过分信任网站，放任来自浏览器地址栏代表的那个网站代码在自己本地任意执行。如果没有浏览器的安全机制限制，xss代码可以在用户浏览器为所欲为；
>
> csrf：网站过分信任用户，放任来自所谓通过访问控制机制的代表合法用户的请求执行网站的某个特定功能

### 构造XSS payload

1. 窃取cookie；
2. 伪造GET、POST请求；
3. 钓鱼（类似CSRF）、收集信息（识别浏览器、安装的软件）。

### XSS攻击平台

简单来说，就是用来利用XSS漏洞的，可以类比于shell与菜刀的关系（猜的）。通过提交含有XSS的漏洞位置，利用平台来方便构造XSS payload 来简化渗透。

> 最简单的XSS平台，通常可以记录访问的url，访问时的cookie等。稍微复杂的功能，可能还会记录键盘输入，获取页面源码，截取网页屏幕等。
>
> 一句话概括：操纵用户客户端执行任意js脚本.脚本能实现什么功能，xss就可以怎样.

对于渗透人员来说，xss平台的存在大大减少了渗透的成本，原本需要费心思构造payload的地方现在直接甩过去一个平台的链接，成本几乎降到了最低。同样，基于此，xss盲打成为了不错的选择，试一试总没什么坏处嘛。

但是同样，很明显XSS平台这种东西的安全问题是很大的。网上的xss平台没有信用背书你敢用？就不怕开发者卷着你的漏洞跑路去做坏事？更进一步来思考的话，就只能是自己搭建xss平台了。这样的成本同样不怎么低。给我的感觉就像是封了乌云之后众位纷纷自己搭建漏洞库一样。

### XSS Worm

至于道哥所说的XSS Worm，简单来说就是利用XSS漏洞生成新的payload进行递归传播，类似蠕虫病毒。

（还是要好好研究一下JavaScript的啊）

### 其他相关姿势

- base标签+相对路径？
- window.name跨域？
- mission impossible（利用只能攻击自己的漏洞）？
- flash xss？
- DOM XSS 攻击与防御？

### XSS防御

- http-only
  - 禁止页面内JS访问带有此标签的cookie，只能解决cookie盗用。
- 检查输入：格式，标签事件名，特殊字符（注意转义），编码
- 检查输出：安全的编码函数：HtmlEncode、JavaScriptEncode

题外话：对于这些注入类的防御，应该在服务器端和客户端同时进行。前者保证有真正的防御功能，而后者则主要用来节省运算资源，且过滤掉普通用户的非法输入。

## 攻击利用

XSS最基本的利用就是盗取Cookie。但除此之外，由于XSS能够执行前端代码，所以能做的事情很多，网上查了查：

 1. 利用vps接受目标传来的数据；

     linux下监听80端口:  `nc -vlp 80`	or	`python -m SimpleHTTPServer 80` 

 2. 盗取cookie：

      1. 利用img标签的 onerror属性；
      2. 直接script标签；
      3. body标签的onload属性。
      4. 基于websocket的DOS攻击；
      5. js挖矿；
      6. 劫持流量恶意跳转

## 绕过姿势

1. 双写script；
2. 大小写；
3. 编码？ ；
4. 利用其他标签的属性、事件：img onerror / a onload；
5. 配合CSRF：
   1. 仿造目标页面，目标点击时会发送cookie到xss平台
6. 绕过长度限制：
   1. 利用事件，如onclick；
   2. 写在别处利用script的src加载；
   3. 藏入location.hash
   4. 利用代码段注释来注释两个输入框之间的代码

## 常见编码函数

>  trim(string,charlist)函数移除字符串两侧的空白字符或其他预定义字符，预定义字符包括、\t、\n、\x0B、\r以及空格，可选参数charlist支持添加额外需要删除的字符。
>
>  mysql_real_escape_string(string,connection)函数会对字符串中的特殊符号（\x00，\n，\r，\，‘，“，\x1a）进行转义。
>
>  stripslashes(string)函数删除字符串中的反斜杠。
>
>  strip_tags() 函数剥去字符串中的 HTML、XML 以及 PHP 的标签，但允许使用<b>标签。addslashes() 函数返回在预定义字符（单引号、双引号、反斜杠、NULL）之前添加反斜杠的字符串。
>
>  htmlspecialchars() 函数把预定义的字符转换为 HTML 实体。
>
>  预定义的字符是：
>
>  - & （和号）成为 &
>  - " （双引号）成为 "
>  - ' （单引号）成为 '
>  - < （小于）成为 <
>  - \> （大于）成为 >

## 各个具体的payload

想了想还是没必要写了，反正都是上面说过的东西。需要注意的点是限制输入长度的处理办法(抓包修改)。

## 参考：

[浅谈XSS攻击的那些事（附常用绕过姿势）](https://www.secpulse.com/archives/57411.html)

[新手指南：DVWA-1.9全级别教程（完结篇，附实例）之XSS](https://www.freebuf.com/articles/web/123779.html)