---

layout: post

title: " DVWA笔记7&8（SQL Injection）"

author: "markt"

---

## 原理

> 1、常见的sql注入按照参数类型可分为两种：**数字型和字符型**。
>
> 当发生注入点的参数为整数时，比如 ID，num，page等，这种形式的就属于数字型注入漏洞。同样，当注入点是字符串时，则称为字符型注入，字符型注入需要引号来闭合。
>
> 2、也可以根据数据库返回的结果，分为**回显注入、报错注入、盲注**。
>
> 回显注入：可以直接在存在注入点的当前页面中获取返回结果。
>
> 报错注入：程序将数据库的返回错误信息直接显示在页面中，虽然没有返回数据库的查询结果，但是可以构造一些报错语句从错误信息中获取想要的结果。
>
> 盲注：程序后端屏蔽了数据库的错误信息，没有直接显示结果也没有报错信息，只能通过数据库的逻辑和延时函数来判断注入的结果。根据表现形式的不同，盲注又分为based boolean和based time两种类型。

个人认为盲注只有基于布尔型和非布尔型。如果只能通过延时函数来判断注入的话只能说是一种权宜之计，是布尔型盲注走不通的时候的退路。

> 3、按照注入位置及方式不同分为：**post注入，get注入，cookie注入，延时注入，搜索注入，base64注入**，无论此种分类如何多，都可以归纳为以上两种形式。

> 数字型注入一般出现在asp php等弱类型语言中，弱类型语言会自动推导变量类型，例如，参数id=1，PHP会自动把ID的数据类型推导为int类型，若是 id=1 and 1=1，则把ID推导为string类型。但是对于Java、c#这类强类型语言，如果把一个字符串转换为int类型，则会抛出异常，无法运行，所以数字型注入一般出现在弱类型的语言当中，强类型语言很少存在。 ? ? ?

## 手工注入思路

> 手工注入关注的是对原理的理解，而脚本则重于效率。各种脚本语言搭配各种数据库，注入的思路层出不穷，所以应先理解注入的原理与思路，而后再学会各种脚本。毕竟那么多注法，很难记全也很难样样精通。

1. 判断注入存在
2. 获取注入点信息： 查询语句字段数——字段顺序——数据库名——表名——列名

order by NUM（据说group by 也可以）——union select 1,2，……——union select 1,2，database（）（MySQL下，下同）

3. 脱裤？

### 盲注

在面对SQL注入的时候，有的应用会有错误信息回显，这无疑是对入侵者有了极大的帮助，知道怎么注错，那离正确的还远吗？然后就有了一个很无聊的概念——盲注，指的是没有错误回显的时候入侵者凭借刁钻的技巧瞎jb注入。

### timing attack

道哥白帽子中的一个概念，指的是利用函数执行时间来判断注入对错。（有个什么BENCHMARK函数可以将参数作为函数执行一定次数次）

### 基于字符集的注入技巧（宽字节注入）？？？



## 目前防御SQL注入的最佳机制：预编译

所谓预编译，简单来说就是把查询语句中的变量用占位符替换，然后随后再传入具体的变量值。那么，为什么这样可以防御注入呢？

先从SQL查询语句执行的原理说起。from - where - group by - having - select - order by。数据库系统执行的方式是from取表装入内存，where筛选，group by 分类having再次筛选形成虚表，select选择其中项最后排序输出。

原本的web程序和数据库之间通信时，是直接把作为查询语句的整条字符串作为数据交到数据库系统里的，而之后的查询语句的编译都是由数据库系统本身完成，只向web程序返回字符串格式的查询结果；而预编译可以理解为把未含有变量的查询语句和变量分两次传入数据库系统（静态），而且很显然这里传入的是数据库系统中更深更底层的地方，大概就是我所说的内存？第一次传入语句之后的编译因为固定死了查询语句的格式而直接将输出结果大大限制，所以哪怕是第二次的变量中包含有不合法的输入，也不能得到非法字符预期的输出结果。动态的占位符与其类似，只不过是将第一次编译放在了服务器端而已（很显然服务器端的编译并没有数据库系统本身来的专业）。下图说的很到位（《WEB应用安全权威指南》）：



![](https://pic4.zhimg.com/80/v2-283c94a1062ce7be8667fe7192421167_hd.png)

### 其他防注入的方法：

1. 检查数据类型：对于数字型输入来说基本可以解决问题；
2. 过滤用户输入，设置黑名单：没有防贼千日的道理，总有可能出现各种疏漏。
3. 提前在数据库系统中写好安全的存储过程（将SQL语句定义在数据库里）
4. 各种各样的安全函数

---

## DVWA手工注入-payload

### low：

​	1	ok

​	1'	报错，语法问题

​	1' # 	ok 说明需要闭合引号

​	payload：

​		1' or '1' = '1

​		1' or 1=1 #

​		1' or 1=1 -- （多一个空格，--注释才能起作用）

### medium：

添加了一个mysql_real_escape_string()函数。

> mysql_real_escape_string()函数转义 SQL 语句中使用的字符串中的特殊字符。下列字符受影响：
> `\x00` `\n` `\r` `\`  `'` `"`  `\x1a`
> 如果成功，则该函数返回被转义的字符串。如果失败，则返回 false

网上查到，绕过此函数的一个方法是基于宽字节注入的，利用jbk编码来进行注入，挺麻烦的。。

还是直接上sqlmap吧。。

​	在linux下：

​	sqlmap -u "http://172.19.244.123/dvwa/vulnerabilities/sqli/?id=&Submit=Submit#" --cookie="security=low; PHPSESSID=fbrqj6poirkcpnh24989a8dg25" --batch -D dvwa -T users -C user,user_id,first_name,password --dump

​	一步步按照最上面说的流程注入爆破。

真是笨。上边明明写的是过滤'," 几个，还不好好想。

这里是数字型注入，所以不涉及到引号的闭合，直接抓包修改参数就可以。可能是阴差阳错吧，思考一下：

**如果是字符型+函数过滤该怎么绕过？**

这里还说明了：有时候会出现前端限制输入的情况，虽然简单，但是容易通过抓包修改绕过，所以要是真的想限制的话还是从后端限制比较好。

### high

在sql查询中添加了一句限制：LIMIT 1，作用是只显示一条查询结果。实际上的防御还是没有变，还是字符型注入。所以继续利用注释注释掉引号的闭合以及后面的LIMIT限制就可以绕过。

另外表单提交是在另外一个网页上进行的，据说这样可以预防sqlmap？（此外据说还有一些奇奇怪怪的过滤/防御函数：）

 ### impossible

新增 Anti-CSRF Token；

新增函数：is_number（）（判断用户输入是否为数字）；

从查询接口限制查询结果只能为一个；

修改为PDO模式，采用预编译的方式基本杜绝了注入的可能。

### 一个疑惑

在面对字符型注入时，把其误认为数字型注入的错误注入居然能返回一条正确的数据？

源码：`$query  = "SELECT first_name, last_name FROM users WHERE user_id = '$id';"; `

当payload（即id变量）为：`2 or 1=1 #`（正确的字符注入应多一个’闭合引号：`2' or 1=1 #`）

成功返回了原本id=2时的正确结果，即查询语句成为了：

`SELECT first_name, last_name FROM users WHERE user_id = '2 or 1=1 #';`

返回了

`SELECT first_name, last_name FROM users WHERE user_id = '2';`

的内容。所以是什么原因？

## 参考：

权威解答：[新手指南：DVWA-1.9全级别教程之SQL Injection](http://www.freebuf.com/articles/web/120747.html)

标准渗透：[通过DVWA学习SQL注入漏洞](https://blog.csdn.net/SKI_12/article/details/56279676)

**[sql注入指南之常见数据库测试总结](https://evilwing.me/2018/01/15/sql%E6%B3%A8%E5%85%A5%E6%8C%87%E5%8D%97%E4%B9%8B%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E5%BA%93%E6%B5%8B%E8%AF%95%E6%80%BB%E7%BB%93/)(很详细，手工注入payload可查)**

群中有大佬表示可以在面对字符型注入+函数过滤时可以考虑二次注入（但是我并不会）[SQL注入（二次注入）](https://zhuanlan.zhihu.com/p/39917830)
